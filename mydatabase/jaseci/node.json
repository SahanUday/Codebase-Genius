[
{"_id": {"$oid": "000000000000000000000000"}, "name": "", "root": null, "access": {"all": "NO_ACCESS", "roots": {"anchors": {}}}, "archetype": {}, "edges": []},
{"_id": {"$oid": "68b0125230d3c4ad89e18c00"}, "name": "DocGenie", "root": {"$oid": "000000000000000000000001"}, "access": {"all": "NO_ACCESS", "roots": {"anchors": {}}}, "archetype": {"repo_url": "", "drafted_chapters": [{"id": "o:Cformat:68b0127f30d3c4ad89e18c10", "context": {"heading": "FeedbackAgent", "highlevel_explanation_section": "The FeedbackAgent serves as the primary user interface component within the SteamNoodles application. Its core function is to allow customers to submit their feedback seamlessly. Upon submission, it communicates with the backend services to process the feedback, displaying the AI-generated response and the results of the sentiment analysis back to the user. This agent ensures a smooth and interactive experience for customers providing their input.", "mermaid_diagram_section": "graph TD\n    User -->|Submits Feedback| FeedbackAgent\n    FeedbackAgent -->|Sends to Backend (e.g., /analyze_feedback)| BackendAPI\n    BackendAPI -->|Returns Analysis & Response| FeedbackAgent\n    FeedbackAgent -->|Displays| User"}}, {"id": "o:Cformat:68b0127f30d3c4ad89e18c11", "context": {"heading": "SentimentDashboard", "highlevel_explanation_section": "The SentimentDashboard provides an interactive and insightful visualization of customer sentiment data. It allows users to explore sentiment trends over various time ranges, view the overall distribution of sentiment (e.g., positive, negative, neutral), and filter feedback by specific business categories. Furthermore, it enables the generation of comprehensive summary reports, offering a high-level overview of customer feedback for a selected period. This component is crucial for business intelligence and decision-making.", "mermaid_diagram_section": "graph TD\n    User -->|Interacts with UI| SentimentDashboard\n    SentimentDashboard -->|Reads Data (e.g., from CSV via backend)| FeedbackPersistenceManager\n    SentimentDashboard -->|Requests Summary (e.g., /generate_summary)| BackendAPI\n    BackendAPI -->|Returns Summary| SentimentDashboard\n    SentimentDashboard -->|Displays Visualizations & Reports| User"}}, {"id": "o:Cformat:68b0127f30d3c4ad89e18c12", "context": {"heading": "FeedbackAnalysisService", "highlevel_explanation_section": "The FeedbackAnalysisService is a critical backend component responsible for intelligently processing raw customer feedback. Upon receiving feedback, it leverages a Large Language Model (LLM) to perform a multi-faceted analysis, determining the sentiment (e.g., very positive, very negative), urgency level, dominant customer emotion, and assigning it to a relevant business category. This service also orchestrates the storage of these detailed analysis results, making the data available for dashboard visualizations and further processing.", "mermaid_diagram_section": "graph TD\n    FeedbackAgent -->|Sends Feedback| FeedbackAnalysisService\n    FeedbackAnalysisService -->|Uses LLM| LLM_Model\n    LLM_Model -->|Returns Analysis (Sentiment, Urgency, Emotion, Category)| FeedbackAnalysisService\n    FeedbackAnalysisService -->|Saves Analysis Results| FeedbackPersistenceManager"}}, {"id": "o:Cformat:68b0127f30d3c4ad89e18c13", "context": {"heading": "CustomerResponseGenerator", "highlevel_explanation_section": "The CustomerResponseGenerator is a specialized backend service designed to craft empathetic and contextually appropriate replies to customer feedback. It takes the analyzed sentiment, urgency, and emotion of a feedback entry and uses an LLM to generate a natural, human-like response. A key feature is its multilingual capability, ensuring that replies are generated in the original language or writing style of the customer's feedback, fostering better communication and customer satisfaction.", "mermaid_diagram_section": "graph TD\n    FeedbackAnalysisService -->|Passes Analysis Results| CustomerResponseGenerator\n    CustomerResponseGenerator -->|Uses LLM| LLM_Model\n    LLM_Model -->|Generates Empathetic Reply| CustomerResponseGenerator\n    CustomerResponseGenerator -->|Returns Reply| FeedbackAgent"}}, {"id": "o:Cformat:68b0127f30d3c4ad89e18c14", "context": {"heading": "SentimentSummaryGenerator", "highlevel_explanation_section": "The SentimentSummaryGenerator is a backend service focused on providing high-level insights into customer sentiment over specific periods. It compiles customer feedback data within a given date range, aggregates sentiment counts, and identifies key positive and negative feedback examples. Utilizing an LLM, it then synthesizes this information into a coherent and insightful summary report, which can be used for strategic planning and understanding overall customer satisfaction trends.", "mermaid_diagram_section": "graph TD\n    SentimentDashboard -->|Requests Summary (Date Range)| SentimentSummaryGenerator\n    SentimentSummaryGenerator -->|Retrieves Feedback Data| FeedbackPersistenceManager\n    FeedbackPersistenceManager -->|Returns Filtered Data| SentimentSummaryGenerator\n    SentimentSummaryGenerator -->|Aggregates & Extracts Examples| SentimentSummaryGenerator\n    SentimentSummaryGenerator -->|Uses LLM| LLM_Model\n    LLM_Model -->|Generates Summary Report| SentimentSummaryGenerator\n    SentimentSummaryGenerator -->|Returns Summary| SentimentDashboard"}}, {"id": "o:Cformat:68b0127f30d3c4ad89e18c15", "context": {"heading": "FeedbackPersistenceManager", "highlevel_explanation_section": "The FeedbackPersistenceManager is responsible for the crucial task of data storage and retrieval within the system. It efficiently manages customer feedback entries and their corresponding analysis results, persisting them to and loading them from a CSV file. This ensures that all feedback data is reliably stored, enabling historical analysis, dashboard visualizations, and the generation of summary reports without data loss. It acts as the central data access layer for feedback-related information.", "mermaid_diagram_section": "graph TD\n    FeedbackAnalysisService -->|Saves Feedback & Analysis| FeedbackPersistenceManager\n    SentimentSummaryGenerator -->|Retrieves Feedback Data| FeedbackPersistenceManager\n    SentimentDashboard -->|Reads Data| FeedbackPersistenceManager\n    FeedbackPersistenceManager -- Reads/Writes --> CSV_File(steamnoodles_feedback_dataset.csv)"}}], "chapters": [{"id": "o:Chapter:68b0127f30d3c4ad89e18c16", "context": {"title": "FeedbackAgent", "content": "Welcome to the first component of our SteamNoodles application: the **FeedbackAgent**. Think of this as the main gateway for our customers to share their thoughts and experiences. It's the primary user interface (UI) where customers submit their feedback seamlessly.\n\nOnce a customer provides their input, the FeedbackAgent doesn't just sit there; it actively communicates with our backend services to process that feedback. After the backend works its magic, the FeedbackAgent then displays the AI-generated response and the results of a sentiment analysis directly back to the user. This ensures a smooth, interactive, and transparent experience for anyone providing feedback.\n\nHere's a high-level view of how the FeedbackAgent interacts with other parts of the system:\n\n```mermaid\ngraph TD\n    User -->|Submits Feedback| FeedbackAgent\n    FeedbackAgent -->|Sends to Backend (e.g., /analyze_feedback)| BackendAPI\n    BackendAPI -->|Returns Analysis & Response| FeedbackAgent\n    FeedbackAgent -->|Displays| User\n```\n\nAs you can see, the FeedbackAgent is crucial for gathering user input and presenting the initial results. But what happens to that feedback once it's sent to the backend? Let's explore the powerful service that takes raw feedback and intelligently processes it."}}, {"id": "o:Chapter:68b0127f30d3c4ad89e18c17", "context": {"title": "SentimentDashboard", "content": "Moving on from how feedback is collected, let's explore how we make sense of all that valuable customer data with the **SentimentDashboard**. This component is your window into the collective voice of your customers. It offers an interactive and insightful visualization of all the customer sentiment data we've gathered.\n\nWith the SentimentDashboard, users can easily:\n*   Explore sentiment trends over various time ranges.\n*   View the overall distribution of sentiment (e.g., how many positive, negative, or neutral comments).\n*   Filter feedback by specific business categories to pinpoint areas of concern or success.\n*   Generate comprehensive summary reports, providing a high-level overview of customer feedback for a selected period.\n\nThis dashboard is an indispensable tool for business intelligence, helping decision-makers understand customer satisfaction and identify areas for improvement.\n\nHere's how the SentimentDashboard retrieves and displays its information:\n\n```mermaid\ngraph TD\n    User -->|Interacts with UI| SentimentDashboard\n    SentimentDashboard -->|Reads Data (e.g., from CSV via backend)| FeedbackPersistenceManager\n    SentimentDashboard -->|Requests Summary (e.g., /generate_summary)| BackendAPI\n    BackendAPI -->|Returns Summary| SentimentDashboard\n    SentimentDashboard -->|Displays Visualizations & Reports| User\n```\n\nThe SentimentDashboard relies heavily on accurately analyzed and stored data to provide its rich insights. This brings us to the core backend service responsible for processing the raw feedback."}}, {"id": "o:Chapter:68b0127f30d3c4ad89e18c18", "context": {"title": "FeedbackAnalysisService", "content": "Now that we've seen how feedback is submitted and displayed, let's dive into the intelligence behind the scenes: the **FeedbackAnalysisService**. This is a critical backend component that acts as the brain of our feedback system, responsible for intelligently processing every piece of raw customer feedback.\n\nWhen the FeedbackAgent sends feedback to the backend, it's the FeedbackAnalysisService that springs into action. It leverages a powerful Large Language Model (LLM) to perform a multi-faceted analysis. This analysis includes:\n*   **Sentiment**: Determining the overall mood (e.g., very positive, very negative, neutral).\n*   **Urgency Level**: Identifying how quickly an issue might need attention.\n*   **Dominant Customer Emotion**: Pinpointing feelings like joy, frustration, or confusion.\n*   **Business Category**: Assigning the feedback to a relevant department or product area.\n\nBeyond just analyzing, this service also orchestrates the storage of these detailed analysis results, making the data readily available for dashboard visualizations (like the SentimentDashboard we just discussed) and further processing.\n\nHere's an overview of its process:\n\n```mermaid\ngraph TD\n    FeedbackAgent -->|Sends Feedback| FeedbackAnalysisService\n    FeedbackAnalysisService -->|Uses LLM| LLM_Model\n    LLM_Model -->|Returns Analysis (Sentiment, Urgency, Emotion, Category)| FeedbackAnalysisService\n    FeedbackAnalysisService -->|Saves Analysis Results| FeedbackPersistenceManager\n```\n\nOnce the feedback has been thoroughly analyzed, what's the next logical step? Crafting a personalized and helpful response for the customer. That's where our next service comes in."}}, {"id": "o:Chapter:68b0127f30d3c4ad89e18c19", "context": {"title": "CustomerResponseGenerator", "content": "Following the detailed analysis performed by the FeedbackAnalysisService, we arrive at a crucial step for customer satisfaction: generating a thoughtful reply. This is the domain of the **CustomerResponseGenerator**, a specialized backend service designed to craft empathetic and contextually appropriate replies to customer feedback.\n\nThis service takes the analyzed sentiment, urgency, and emotion of a feedback entry and, once again, leverages a Large Language Model (LLM) to generate a natural, human-like response. A standout feature of the CustomerResponseGenerator is its multilingual capability. This ensures that replies are generated in the original language or writing style of the customer's feedback, fostering better communication and significantly enhancing customer satisfaction. Imagine receiving a perfect reply in your native tongue, even if the company's primary language is different!\n\nHere's how it fits into the feedback loop:\n\n```mermaid\ngraph TD\n    FeedbackAnalysisService -->|Passes Analysis Results| CustomerResponseGenerator\n    CustomerResponseGenerator -->|Uses LLM| LLM_Model\n    LLM_Model -->|Generates Empathetic Reply| CustomerResponseGenerator\n    CustomerResponseGenerator -->|Returns Reply| FeedbackAgent\n```\n\nSo, we've analyzed the feedback and generated a response. But what about getting a bigger picture, a summary of feedback over time? And where is all this valuable data actually stored? Let's explore these aspects next."}}, {"id": "o:Chapter:68b0127f30d3c4ad89e18c1a", "context": {"title": "SentimentSummaryGenerator", "content": "Beyond individual feedback analysis and responses, businesses often need a high-level understanding of customer sentiment over specific periods. This is precisely the role of the **SentimentSummaryGenerator**. This backend service focuses on providing aggregated insights, making it easier to grasp overall trends.\n\nWhen a user (perhaps from the SentimentDashboard) requests a summary for a particular date range, this service springs into action. It compiles all relevant customer feedback data within that period, aggregates sentiment counts (e.g., total positive, negative, neutral), and identifies key positive and negative feedback examples to illustrate the trends. Finally, utilizing an LLM, it synthesizes all this information into a coherent and insightful summary report. This report is invaluable for strategic planning, understanding overall customer satisfaction trends, and identifying long-term areas for improvement.\n\nLet's visualize its workflow:\n\n```mermaid\ngraph TD\n    SentimentDashboard -->|Requests Summary (Date Range)| SentimentSummaryGenerator\n    SentimentSummaryGenerator -->|Retrieves Feedback Data| FeedbackPersistenceManager\n    FeedbackPersistenceManager -->|Returns Filtered Data| SentimentSummaryGenerator\n    SentimentSummaryGenerator -->|Aggregates & Extracts Examples| SentimentSummaryGenerator\n    SentimentSummaryGenerator -->|Uses LLM| LLM_Model\n    LLM_Model -->|Generates Summary Report| SentimentSummaryGenerator\n    SentimentSummaryGenerator -->|Returns Summary| SentimentDashboard\n```\n\nYou might have noticed that several components, including this one, interact with something called the 'FeedbackPersistenceManager'. This brings us to the fundamental component that ensures all our valuable feedback data is safely stored and readily available."}}, {"id": "o:Chapter:68b0127f30d3c4ad89e18c1b", "context": {"title": "FeedbackPersistenceManager", "content": "Finally, we arrive at the backbone of our data management: the **FeedbackPersistenceManager**. This component is responsible for the crucial task of data storage and retrieval within the entire SteamNoodles system. Without it, all the intelligent analysis and response generation would be temporary and lost.\n\nThe FeedbackPersistenceManager efficiently manages customer feedback entries and their corresponding analysis results, persisting them to and loading them from a CSV file (specifically, `steamnoodles_feedback_dataset.csv`). This ensures that all feedback data is reliably stored, making it available for:\n*   Historical analysis (e.g., tracking sentiment over months).\n*   Dashboard visualizations (as seen in the SentimentDashboard).\n*   The generation of summary reports (by the SentimentSummaryGenerator).\n\nIt acts as the central data access layer for all feedback-related information, ensuring data integrity and availability across the application.\n\nHere's how various services interact with it:\n\n```mermaid\ngraph TD\n    FeedbackAnalysisService -->|Saves Feedback & Analysis| FeedbackPersistenceManager\n    SentimentSummaryGenerator -->|Retrieves Feedback Data| FeedbackPersistenceManager\n    SentimentDashboard -->|Reads Data| FeedbackPersistenceManager\n    FeedbackPersistenceManager -- Reads/Writes --> CSV_File(steamnoodles_feedback_dataset.csv)\n```\n\nAnd there you have it! From the moment a customer submits feedback through the FeedbackAgent, to its intelligent analysis by the FeedbackAnalysisService, the empathetic response generated by the CustomerResponseGenerator, the insightful visualizations on the SentimentDashboard, the high-level summaries from the SentimentSummaryGenerator, and the reliable storage by the FeedbackPersistenceManager \u2013 every piece works in harmony to create a robust and intelligent feedback system. This comprehensive ecosystem ensures that every customer's voice is heard, understood, and acted upon, driving continuous improvement and customer satisfaction for SteamNoodles."}}]}, "edges": ["e::68b0125230d3c4ad89e18c01"]},
{"_id": {"$oid": "68b011f430d3c4ad89e18bfc"}, "name": "RepoMapper", "root": {"$oid": "000000000000000000000001"}, "access": {"all": "NO_ACCESS", "roots": {"anchors": {}}}, "archetype": {"repo_url": "", "folder_structure": ["E:\\GitHub_Repo\\Codebase-Genius\\AirVix-App\\app.py", "E:\\GitHub_Repo\\Codebase-Genius\\AirVix-App\\main.py"], "summary": "The SteamNoodles Feedback Agent System is an AI-powered solution for customer feedback analysis, offering real-time sentiment analysis, automated response generation, and comprehensive dashboard analytics for the SteamNoodles restaurant chain. Developed by Sahan Udayanga, a 3rd-year student at the University of Moratuwa, the system features two intelligent agents.\n\nThe Feedback Analysis Agent processes customer feedback to generate human-like, context-aware responses in multiple languages, including English, Sinhala (with culturally appropriate phrasing), Singlish, and Tamil. It performs intelligent analysis, detecting sentiment (Very Negative to Very Positive), urgency levels (Low, Medium, High), emotions (e.g., anger, joy, frustration), and classifying feedback into business categories such as Food Quality, Delivery, Customer Service, Pricing, Cleanliness, Take away, Waiting Time, and Other. This agent ensures real-time processing and response generation, supporting multi-language input and output.\n\nThe Sentiment Dashboard Agent provides comprehensive visualization and analysis tools. Users can navigate to the \"Sentiment Dashboard\" page, select flexible time ranges (Last 7 Days, Last 30 Days, or Custom Range for specific start/end dates), and view sentiment trends. It offers interactive visualizations, allowing users to switch between a line chart (Sentiment Trend Visualization) showing how sentiment categories (Very Positive, Positive, Neutral, Negative, Very Negative) change over time, and a pie chart (Sentiment Distribution Pie Chart) providing an at-a-glance view of overall sentiment distribution. The dashboard also features feedback category selection, enabling users to filter by business categories like Food Quality, Pricing, Cleanliness, Delivery, and Other, displaying specific feedback examples from the selected category based on CSV data. Finally, it can generate AI-powered summary reports, offering comprehensive insights into customer sentiment, highlighting key trends, successes, and areas for improvement for any selected time period.\n\nThe system leverages Google's Gemini model for its core analytical capabilities. The architecture uses Flask for backend API services and Streamlit for the interactive frontend dashboard. It supports multilingual feedback handling by automatically detecting input language and generating responses in the same language. Feedback data is stored in a CSV format, capturing timestamp, feedback, sentiment, urgency, emotion, and category.\n\nSetup requires Python 3.10+, Git, and a Google Gemini API key, with dependencies installed via requirements.txt. The application is launched by starting the Flask backend (python main.py) and Streamlit frontend (streamlit run app.py). Users can test the Feedback Agent by submitting feedback to view analysis and responses, or explore the Sentiment Dashboard for visualizations, data filtering, and AI-generated reports. Sample outputs demonstrate accurate multilingual analysis and appropriate response generation, handling diverse feedback like positive English and Sinhala comments, and balancing positive food experience with negative waiting time. The project is licensed under the MIT License."}, "edges": ["e::68b011f430d3c4ad89e18bfd"]},
{"_id": {"$oid": "68b0122430d3c4ad89e18bfe"}, "name": "CodeAnalyzer", "root": {"$oid": "000000000000000000000001"}, "access": {"all": "NO_ACCESS", "roots": {"anchors": {}}}, "archetype": {"code_base": {"app_py": ["import streamlit as st\nimport pandas as pd\nimport requests\nimport plotly.express as px\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"SteamNoodles Feedback Agents\", page_icon=\"\ud83c\udf5c\", layout=\"wide\")\n\n# ---- Sidebar Navigation with Buttons ----\nst.sidebar.title(\"\ud83c\udf5c SteamNoodles\")\n\nif 'page' not in st.session_state:\n    st.session_state.page = \"\ud83d\udce8 Feedback Agent\"\n\nif st.sidebar.button(\"\ud83d\udce8 Feedback Agent\"):\n    st.session_state.page = \"\ud83d\udce8 Feedback Agent\"\nif st.sidebar.button(\"\ud83d\udcca Sentiment Dashboard\"):\n    st.session_state.page = \"\ud83d\udcca Sentiment Dashboard\"\n\npage = st.session_state.page\n\n# ---- Agent 1: Feedback Analyzer ----\nif page == \"\ud83d\udce8 Feedback Agent\":\n    st.title(\"\ud83d\udce8 Feedback Agent\")\n    st.markdown(\"##### Enter customer feedback.\")\n    with st.form(\"feedback_form\"):\n        feedback = st.text_area(\"\ud83d\udcdd Customer Feedback\", height=150)\n        submitted = st.form_submit_button(\" Submit \")\n\n    if submitted and feedback:\n        with st.spinner(\"Please wait....\"):\n         \n            res = requests.post(\"http://localhost:5000/analyze_feedback\", json={\"feedback\": feedback})\n            data = res.json()\n            if \"reply\" in data:\n                st.success(\"\u2705 Feedback processed successfully!\")\n                st.markdown(\"### \ud83d\udcac Auto-Generated Response\")\n                st.markdown(data['reply'].replace(\"\\n\", \"  \\n\"))\n\n# ---- Agent 2: Sentiment Visualization ----\nelif page == \"\ud83d\udcca Sentiment Dashboard\":\n    st.title(\"\ud83d\udcca Sentiment Trend Dashboard\")\n\n    df = pd.read_csv(\"steamnoodles_feedback_dataset.csv\")\n    df[\"timestamp\"] = pd.to_datetime(df[\"timestamp\"])\n\n    today = datetime.today().date()\n\n    range_option = st.selectbox(\n        \"Select time range\",\n        options=[\"Last 7 Days\", \"Last 30 Days\", \"Custom Range\"],\n        index=0\n    )\n\n    if range_option == \"Last 7 Days\":\n        start_date = today - timedelta(days=7)\n        end_date = today\n    elif range_option == \"Last 30 Days\":\n        start_date = today - timedelta(days=30)\n        end_date = today\n    else:\n        start_date = st.date_input(\"Start date\", today - timedelta(days=7))\n        end_date = st.date_input(\"End date\", today)\n\n    if start_date > end_date:\n        st.error(\"\u274c Start date must be before or equal to end date.\")\n        st.stop()\n\n    mask = (df[\"timestamp\"].dt.date >= start_date) & (df[\"timestamp\"].dt.date <= end_date)\n    filtered_df = df.loc[mask]\n\n    if filtered_df.empty:\n        st.info(\"No feedback entries found in this range.\")\n    else:\n        trend_df = filtered_df.groupby([filtered_df[\"timestamp\"].dt.date, \"sentiment\"]).size().reset_index(name=\"count\")\n        trend_df.columns = [\"date\", \"sentiment\", \"count\"]\n\n        st.markdown(\"## \ud83d\udc46 Select Visualization Type\")\n        col1, col2 = st.columns(2)\n        with col1:\n            show_trend = st.button(\"\ud83d\udcc8 Show Trend Plot\")\n        with col2:\n            show_pie = st.button(\"\ud83e\udd67 Show Total Sentiment Pie Chart\")\n\n        if (\"show_trend\" not in st.session_state) and (\"show_pie\" not in st.session_state):\n            st.session_state.show_trend = True\n            st.session_state.show_pie = False\n        if show_trend:\n            st.session_state.show_trend = True\n            st.session_state.show_pie = False\n        if show_pie:\n            st.session_state.show_trend = False\n            st.session_state.show_pie = True\n\n        if st.session_state.show_trend:\n            st.markdown(\"## \ud83d\udcc8 Sentiment Trends Over Time\")\n            fig_line = px.line(trend_df, x=\"date\", y=\"count\", color=\"sentiment\", markers=True,\n                               title=\"Sentiment Counts by Day\",\n                               labels={\"count\": \"Feedback Count\", \"date\": \"Date\"},\n                               hover_data={\"count\": True, \"sentiment\": True, \"date\": True})\n            fig_line.update_layout(hovermode=\"x unified\")\n            fig_line.update_traces(mode=\"lines+markers\")\n            st.plotly_chart(fig_line, use_container_width=True)\n\n        elif st.session_state.show_pie:\n            total_counts = filtered_df['sentiment'].value_counts().reset_index()\n            total_counts.columns = ['sentiment', 'count']\n\n            st.markdown(\"## \ud83e\udd67 Total Sentiment Distribution\")\n            fig_pie = px.pie(total_counts, values='count', names='sentiment',\n                             title=\"Overall Sentiment Distribution in Selected Period\",\n                             color='sentiment',\n                             color_discrete_map={\n                                 \"Very Positive\": \"green\",\n                                 \"Positive\": \"lightgreen\",\n                                 \"Neutral\": \"gray\",\n                                 \"Negative\": \"orange\",\n                                 \"Very Negative\": \"red\"\n                             })\n            fig_pie.update_traces(textposition='inside', textinfo='percent+label')\n            st.plotly_chart(fig_pie, use_container_width=True)\n\n        # Generate Summary button & display summary\n\n        st.markdown(\"### \ud83d\udcc2 Select Feedback Category\")\n\n        categories = [\"Food Quality\", \"Pricing\", \"Cleanliness\", \"Delivery\", \"Other\"]\n\n        if \"selected_category\" not in st.session_state:\n            st.session_state.selected_category = None\n\n        col_cat = st.columns(len(categories))\n        for idx, cat in enumerate(categories):\n            if col_cat[idx].button(cat):\n                if st.session_state.selected_category == cat:\n                    st.session_state.selected_category = None  # unselect if same clicked\n                else:\n                    st.session_state.selected_category = cat\n\n        # Show example feedback for selected category\n        if st.session_state.selected_category:\n            st.markdown(f\"#### \u2728 Example Feedback for **{st.session_state.selected_category}**\")\n\n            # Ensure your dataset has a 'category' column, else you need logic to assign categories\n            if \"category\" in filtered_df.columns:\n                examples_df = filtered_df[filtered_df[\"category\"] == st.session_state.selected_category]\n            else:\n                examples_df = pd.DataFrame(columns=df.columns)  # fallback empty\n\n            if not examples_df.empty:\n                sample_texts = examples_df[\"feedback\"].dropna().sample(min(5, len(examples_df)), random_state=42)\n                for i, fb in enumerate(sample_texts, 1):\n                    st.markdown(f\"**{i}.** {fb}\")\n            else:\n                st.info(\"No feedback found for this category in the selected date range.\")\n\n        st.markdown(f\"### \ud83d\udcdd Summary Report\")\n\n        if st.button(\"\ud83d\udcdd Generate Summary\"):\n            with st.spinner(\"Generating summary...\"):\n           \n                res = requests.post(\n                    \"http://localhost:5000/generate_summary\",\n                    json={\n                        \"start_date\": start_date.strftime(\"%Y-%m-%d\"),\n                        \"end_date\": end_date.strftime(\"%Y-%m-%d\")\n                    }\n                )\n                res_data = res.json()\n                st.markdown(f\"#### Customer Sentiment Summary Report: {start_date.strftime('%Y-%m-%d')} - {end_date.strftime('%Y-%m-%d')}\")\n                st.write(res_data.get(\"summary\", \"No summary generated.\"))\n"], "main_py": ["from flask import Flask, request, jsonify\nfrom langchain_google_genai import GoogleGenerativeAI\nfrom langchain.prompts import PromptTemplate\nfrom dotenv import load_dotenv\nfrom datetime import datetime\nimport os, csv, pandas as pd\n\nload_dotenv()\napp = Flask(__name__)\napi_key = os.getenv(\"GOOGLE_API_KEY\")\nllm = GoogleGenerativeAI(model=\"gemini-2.5-flash\", google_api_key=api_key)\n\n@app.route(\"/generate_summary\", methods=[\"POST\"])\ndef generate_summary():\n    data = request.get_json()\n    start_date_str = data.get(\"start_date\")\n    end_date_str = data.get(\"end_date\")\n\n    start_date = datetime.strptime(start_date_str, \"%Y-%m-%d\").date()\n    end_date = datetime.strptime(end_date_str, \"%Y-%m-%d\").date()\n\n    # Read CSV and filter by date\n    if not os.path.isfile(\"steamnoodles_feedback_dataset.csv\"):\n        return jsonify({\"error\": \"Feedback dataset not found.\"}), 404\n\n    df = pd.read_csv(\"steamnoodles_feedback_dataset.csv\")\n    df[\"timestamp\"] = pd.to_datetime(df[\"timestamp\"]).dt.date\n\n    filtered = df[(df[\"timestamp\"] >= start_date) & (df[\"timestamp\"] <= end_date)]\n    counts = filtered[\"sentiment\"].value_counts().to_dict()\n\n    very_positive = counts.get(\"Very Positive\", 0)\n    positive = counts.get(\"Positive\", 0)\n    neutral = counts.get(\"Neutral\", 0)\n    negative = counts.get(\"Negative\", 0)\n    very_negative = counts.get(\"Very Negative\", 0)\n\n    # Collect actual feedback texts for very positive and very negative\n    very_positive_feedbacks = filtered[filtered[\"sentiment\"] == \"Very Positive\"][\"feedback\"].tolist()\n    very_negative_feedbacks = filtered[filtered[\"sentiment\"] == \"Very Negative\"][\"feedback\"].tolist()\n\n    # Format feedbacks for prompt\n    very_positive_text = \"\\n\".join(very_positive_feedbacks[:5]) if very_positive_feedbacks else \"None\"\n    very_negative_text = \"\\n\".join(very_negative_feedbacks[:5]) if very_negative_feedbacks else \"None\"\n\n    # PROMPT : Generate summary\n    summary_prompt = f\"\"\"\nYour summary MUST mention both the very positive and very negative feedbacks, using provided counts and using the sample comments and counts to highlight key strengths and urgent issues. \nSummarize the overall customer sentiment trend, notable positives, and areas needing immediate attention. Do not include any heading or title in your summary.\nGenerate paragraphs that are coherent and contextually relevant, ensuring a smooth flow of ideas.\nAdd last paragraph by including overall overveiw of the summarize\n\nSentiment Counts:\nVery Positive: {very_positive}\nPositive: {positive}\nNeutral: {neutral}\nNegative: {negative}\nVery Negative: {very_negative}\n\nSample Very Positive Feedbacks:\n{very_positive_text}\n\nSample Very Negative Feedbacks:\n{very_negative_text}\n\nSummarize the overall customer sentiment trend, highlighting notable positives and areas needing urgent attention. Use the sample feedbacks to provide concrete examples in your summary.\n\"\"\"\n    \n    summary = llm.invoke(summary_prompt).strip()\n    return jsonify({\"summary\": summary})\n\n# PROMPT 1: Feedback analysis (analytics + category classification)\nanalysis_prompt = PromptTemplate.from_template(\n    \"\"\"\nYou are a feedback analysis assistant for SteamNoodles, a rapidly growing restaurant chain.\n\nAnalyze the following customer feedback and provide:\n1. Fine-grained sentiment (Very Negative / Negative / Neutral / Positive / Very Positive)\n2. Urgency level (Low / Medium / High)\n3. Dominant customer emotion (anger, joy, frustration, gratitude, disappointment, etc.)\n4. Business category (one of: Food Quality, Delivery, Customer Service, Pricing, Cleanliness, Take away, Waiting Time, Other)\n\nOnly return your answer in this exact format:\nSentiment: <sentiment>\nUrgency: <urgency>\nEmotion: <emotion>\nCategory: <category>\n\nFeedback:\n\"{feedback}\"\n\"\"\"\n)\n\n# PROMPT 2: Human-like response generation with multilingual support\nresponse_prompt = PromptTemplate.from_template(\n    \"\"\"\nYou are a warm, emotionally intelligent automated customer support responder of the restaurant.\nYou automatically write replies to customer feedbacks.\nYour task is to generate a short, natural, context-aware and kind reply based on the feedback, sentiment, urgency, and emotion. Adapt the tone to match the emotion and urgency.\n\nRULES:\n- Use the **same language(eg: \u0dc3\u0dd2\u0d82\u0dc4\u0dbd->\u0dc3\u0dd2\u0d82\u0dc4\u0dbd) or transliteration style(e.g., Singlish:Sinhala in English letters \u2192 \u0dc3\u0dd2\u0d82\u0dc4\u0dbd)** as the feedback .\n- Always reply in the **same language and writing style** as the customer's original feedback.\n- If feedback is in Sinhala, reply in Sinhala.\n- If it's Tamil, reply in Tamil.\n- If it's English, reply in English.\n- If feedback is Sinhala/Tamil typed using English letters (like Singlish or Tanglish), reply using the Sinhala or Tamil (not typed using English letters).\n- Do NOT use formal or overly structured grammar in such cases.\n- Avoid robotic or unnatural phrasing. Make it sound like a human wrote it, not robotic or overly structured.\n- Never ask follow-up questions. This is a one-way automatic reply.\n- Express empathy, kindness, and a sense of care.\n- Match the tone to the customer's emotion and urgency.\n- Use emojis to enhance warmth and empathy.\n\nGiven the customer's feedback, sentiment, urgency, and emotion as follows,\nwrite a short, natural, context-aware and kind reply based on the feedback,sentiment, urgency,emotion. Adapt the tone to match the emotion and urgency.\n\nFeedback: {feedback}\nSentiment: {sentiment}\nUrgency: {urgency}\nEmotion: {emotion}\n\nReply:\n\"\"\"\n)\n\ndef save_to_csv(feedback, sentiment, urgency, emotion, category, reply, filename=\"steamnoodles_feedback_dataset.csv\"):\n    file_exists = os.path.isfile(filename)\n    with open(filename, mode=\"a\", newline=\"\", encoding=\"utf-8\") as f:\n        writer = csv.writer(f)\n        if not file_exists:\n            writer.writerow([\"timestamp\", \"feedback\", \"sentiment\", \"urgency\", \"emotion\", \"category\"])\n        writer.writerow([datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"), feedback, sentiment, urgency, emotion, category])\n\n@app.route(\"/analyze_feedback\", methods=[\"POST\"])\ndef analyze_feedback():\n    data = request.get_json()\n    feedback = data.get(\"feedback\", \"\").strip()\n    if not feedback:\n        return jsonify({\"error\": \"Feedback is required\"}), 400\n\n    analysis = llm.invoke(analysis_prompt.format(feedback=feedback)).strip()\n    sentiment = analysis.split(\"Sentiment:\")[1].split(\"\\n\")[0].strip()\n    urgency = analysis.split(\"Urgency:\")[1].split(\"\\n\")[0].strip()\n    emotion = analysis.split(\"Emotion:\")[1].split(\"\\n\")[0].strip()\n    category = analysis.split(\"Category:\")[1].strip()\n\n    response = llm.invoke(response_prompt.format(\n        feedback=feedback,\n        sentiment=sentiment,\n        urgency=urgency,\n        emotion=emotion\n    )).strip()\n\n    save_to_csv(feedback, sentiment, urgency, emotion, category, response)\n\n    return jsonify({\n        \"sentiment\": sentiment,\n        \"urgency\": urgency,\n        \"emotion\": emotion,\n        \"category\": category,\n        \"reply\": response\n    })\n\nif __name__ == \"__main__\":\n    app.run(port=5000)\n"]}, "abstractions": [{"id": "o:Absts:68b0127f30d3c4ad89e18c02", "context": {"name": "FeedbackAgent", "description": "Manages the user interface for submitting customer feedback and displaying the AI-generated response and analysis results. It interacts with the backend to process feedback.", "related_files": ["app.py"]}}, {"id": "o:Absts:68b0127f30d3c4ad89e18c03", "context": {"name": "SentimentDashboard", "description": "Provides an interactive dashboard for visualizing customer sentiment trends over time, displaying overall sentiment distribution, filtering feedback by categories, and generating summary reports.", "related_files": ["app.py"]}}, {"id": "o:Absts:68b0127f30d3c4ad89e18c04", "context": {"name": "FeedbackAnalysisService", "description": "A backend service responsible for receiving raw customer feedback, using an LLM to determine its sentiment, urgency, dominant emotion, and business category. It also orchestrates saving the analysis results.", "related_files": ["main.py"]}}, {"id": "o:Absts:68b0127f30d3c4ad89e18c05", "context": {"name": "CustomerResponseGenerator", "description": "A backend service that generates empathetic, context-aware, and multilingual replies to customer feedback based on its analyzed sentiment, urgency, and emotion, ensuring a natural human-like tone.", "related_files": ["main.py"]}}, {"id": "o:Absts:68b0127f30d3c4ad89e18c06", "context": {"name": "SentimentSummaryGenerator", "description": "A backend service that compiles and summarizes customer sentiment data for a specified date range. It aggregates sentiment counts, extracts key positive and negative feedback examples, and uses an LLM to generate a coherent summary report.", "related_files": ["main.py"]}}, {"id": "o:Absts:68b0127f30d3c4ad89e18c07", "context": {"name": "FeedbackPersistenceManager", "description": "Manages the storage and retrieval of customer feedback and its analysis results to and from a CSV file, ensuring data persistence for dashboard visualizations and summary generation.", "related_files": ["main.py"]}}], "relationships": [{"id": "o:Rels:68b0127f30d3c4ad89e18c08", "context": {"from_abstraction": "FeedbackAgent", "to_abstraction": "FeedbackAnalysisService", "label": "Submits feedback"}}, {"id": "o:Rels:68b0127f30d3c4ad89e18c09", "context": {"from_abstraction": "FeedbackAnalysisService", "to_abstraction": "CustomerResponseGenerator", "label": "Provides analysis"}}, {"id": "o:Rels:68b0127f30d3c4ad89e18c0a", "context": {"from_abstraction": "FeedbackAnalysisService", "to_abstraction": "FeedbackPersistenceManager", "label": "Stores analysis results"}}, {"id": "o:Rels:68b0127f30d3c4ad89e18c0b", "context": {"from_abstraction": "CustomerResponseGenerator", "to_abstraction": "FeedbackAgent", "label": "Sends AI response"}}, {"id": "o:Rels:68b0127f30d3c4ad89e18c0c", "context": {"from_abstraction": "FeedbackAnalysisService", "to_abstraction": "FeedbackAgent", "label": "Sends analysis results"}}, {"id": "o:Rels:68b0127f30d3c4ad89e18c0d", "context": {"from_abstraction": "FeedbackPersistenceManager", "to_abstraction": "SentimentDashboard", "label": "Provides data for display"}}, {"id": "o:Rels:68b0127f30d3c4ad89e18c0e", "context": {"from_abstraction": "SentimentDashboard", "to_abstraction": "SentimentSummaryGenerator", "label": "Triggers summary report"}}, {"id": "o:Rels:68b0127f30d3c4ad89e18c0f", "context": {"from_abstraction": "FeedbackPersistenceManager", "to_abstraction": "SentimentSummaryGenerator", "label": "Provides data for summary"}}], "chapter_order": [{"$numberInt": "0"}, {"$numberInt": "1"}, {"$numberInt": "5"}, {"$numberInt": "2"}, {"$numberInt": "3"}, {"$numberInt": "4"}]}, "edges": ["e::68b0122430d3c4ad89e18bff"]},
{"_id": {"$oid": "000000000000000000000001"}, "name": "", "root": null, "access": {"all": "WRITE", "roots": {"anchors": {}}}, "archetype": {}, "edges": ["e::68b011f430d3c4ad89e18bfd", "e::68b0122430d3c4ad89e18bff", "e::68b0125230d3c4ad89e18c01"]}
]